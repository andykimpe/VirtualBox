Index: VirtualBox-5.1.4/src/VBox/Additions/linux/drm/vbox_ttm.c
===================================================================
--- VirtualBox-5.1.4.orig/src/VBox/Additions/linux/drm/vbox_ttm.c
+++ VirtualBox-5.1.4/src/VBox/Additions/linux/drm/vbox_ttm.c
@@ -221,7 +221,11 @@ static int vbox_bo_move(struct ttm_buffe
                struct ttm_mem_reg *new_mem)
 {
     int r;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
     r = ttm_bo_move_memcpy(bo, evict, no_wait_gpu, new_mem);
+#else
+    r = ttm_bo_move_memcpy(bo, evict, interruptible, no_wait_gpu, new_mem);
+#endif
     return r;
 }
 
Index: VirtualBox-5.1.4/src/VBox/Additions/linux/drm/vbox_drv.c
===================================================================
--- VirtualBox-5.1.4.orig/src/VBox/Additions/linux/drm/vbox_drv.c
+++ VirtualBox-5.1.4/src/VBox/Additions/linux/drm/vbox_drv.c
@@ -244,9 +244,14 @@ static int vbox_master_set(struct drm_de
     return 0;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
 static void vbox_master_drop(struct drm_device *dev,
                              struct drm_file *file_priv,
                              bool from_release)
+#else
+static void vbox_master_drop(struct drm_device *dev,
+                             struct drm_file *file_priv)
+#endif
 {
     struct vbox_private *vbox = dev->dev_private;
     vbox->initial_mode_queried = false;
Index: VirtualBox-5.1.4/src/VBox/Runtime/r0drv/linux/alloc-r0drv-linux.c
===================================================================
--- VirtualBox-5.1.4.orig/src/VBox/Runtime/r0drv/linux/alloc-r0drv-linux.c
+++ VirtualBox-5.1.4/src/VBox/Runtime/r0drv/linux/alloc-r0drv-linux.c
@@ -35,7 +35,7 @@
 #include <iprt/assert.h>
 #include <iprt/err.h>
 #include "r0drv/alloc-r0drv.h"
-
+#include <linux/kmemleak.h>
 
 #if (defined(RT_ARCH_AMD64) || defined(DOXYGEN_RUNNING)) && !defined(RTMEMALLOC_EXEC_HEAP)
 # if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
@@ -294,6 +294,7 @@ DECLHIDDEN(int) rtR0MemAllocEx(size_t cb
                 fFlags &= ~RTMEMHDR_FLAG_KMALLOC;
                 pHdr = vmalloc(cb + sizeof(*pHdr));
             }
+	    kmemleak_not_leak(pHdr);
         }
         else
             pHdr = vmalloc(cb + sizeof(*pHdr));
