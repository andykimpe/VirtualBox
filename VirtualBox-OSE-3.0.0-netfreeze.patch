r21126 | vboxsync | 2009-07-01 16:11:27 +0200 (Wed, 01 Jul 2009) | 2 lines
PDMR3QueueFlushAll: The bit number, not the mask.

r21128 | vboxsync | 2009-07-01 16:46:19 +0200 (Wed, 01 Jul 2009) | 1 line
PDMQueue: Fixed the flushing loop when a consumer (NAT?) had had enough.

r21151 | vboxsync | 2009-07-02 13:47:24 +0200 (Thu, 02 Jul 2009) | 1 line
PDMQueue: Fixed leaking the last pending item when the consume returned false. Also, be more paranoid whe returning unconsumed items to the pending list.

r21153 | vboxsync | 2009-07-02 13:50:23 +0200 (Thu, 02 Jul 2009) | 1 line
PDMQueue: tyop.

diff -up VirtualBox-3.0.0_OSE/src/VBox/VMM/PDMInternal.h.netfreeze VirtualBox-3.0.0_OSE/src/VBox/VMM/PDMInternal.h
--- VirtualBox-3.0.0_OSE/src/VBox/VMM/PDMInternal.h.netfreeze	2009-06-30 12:21:58.000000000 +0200
+++ VirtualBox-3.0.0_OSE/src/VBox/VMM/PDMInternal.h	2009-07-10 14:57:54.000000000 +0200
@@ -723,6 +723,21 @@ typedef struct PDMQUEUE
     }                               aFreeItems[1];
 } PDMQUEUE;
 
+/** @name PDM::fQueueFlushing
+ * @{ */
+/** Indicating that an queue insert has been performed. */
+#define PDM_QUEUE_FLUSH_FLAG_ACTIVE         RT_BIT_32(PDM_QUEUE_FLUSH_FLAG_ACTIVE_BIT)
+/** The bit number for PDM_QUEUE_FLUSH_FLAG_ACTIVE_BIT.  */
+#define PDM_QUEUE_FLUSH_FLAG_ACTIVE_BIT     0
+/** Indicating there are pending items.
+ * This is make sure we don't miss inserts happening during flushing. The FF
+ * cannot be used for this since it has to be cleared immediately to prevent
+ * other EMTs from spinning. */
+#define PDM_QUEUE_FLUSH_FLAG_PENDING        RT_BIT_32(PDM_QUEUE_FLUSH_FLAG_PENDING_BIT)
+/** The bit number for PDM_QUEUE_FLUSH_FLAG_PENDING.  */
+#define PDM_QUEUE_FLUSH_FLAG_PENDING_BIT    1
+/** }@  */
+
 
 /**
  * Queue device helper task operation.
@@ -887,8 +902,9 @@ typedef struct PDM
     /** Pointer to the queue which should be manually flushed - RC Ptr.
      * Only touched by EMT. */
     RCPTRTYPE(struct PDMQUEUE *)    pQueueFlushRC;
-    /** Set if we're currently checking queues to prevent other VCPUs from doing the same concurrently. */
-    volatile uint32_t               fQueueFlushing;
+    /** Bitmask controlling the queue flushing.
+     * See PDM_QUEUE_FLUSH_FLAG_ACTIVE and PDM_QUEUE_FLUSH_FLAG_PENDING. */
+    uint32_t volatile               fQueueFlushing;
 
     /** Head of the PDM Thread list. (singly linked) */
     R3PTRTYPE(PPDMTHREAD)           pThreads;
diff -up VirtualBox-3.0.0_OSE/src/VBox/VMM/PDMQueue.cpp.netfreeze VirtualBox-3.0.0_OSE/src/VBox/VMM/PDMQueue.cpp
--- VirtualBox-3.0.0_OSE/src/VBox/VMM/PDMQueue.cpp.netfreeze	2009-07-10 14:57:54.117409044 +0200
+++ VirtualBox-3.0.0_OSE/src/VBox/VMM/PDMQueue.cpp	2009-07-10 14:57:54.000000000 +0200
@@ -672,7 +672,7 @@ static bool pdmR3QueueFlush(PPDMQUEUE pQ
     if (    !pItems
         &&  !pItemsRC
         &&  !pItemsR0)
-        /* Somebody was racing us. */
+        /* Somebody may be racing us ... never mind. */
         return true;
 
     /*
@@ -721,10 +721,10 @@ static bool pdmR3QueueFlush(PPDMQUEUE pQ
         case PDMQUEUETYPE_DEV:
             while (pItems)
             {
+                if (!pQueue->u.Dev.pfnCallback(pQueue->u.Dev.pDevIns, pItems))
+                    break;
                 pCur = pItems;
                 pItems = pItems->pNextR3;
-                if (!pQueue->u.Dev.pfnCallback(pQueue->u.Dev.pDevIns, pCur))
-                    break;
                 pdmR3QueueFree(pQueue, pCur);
             }
             break;
@@ -732,10 +732,10 @@ static bool pdmR3QueueFlush(PPDMQUEUE pQ
         case PDMQUEUETYPE_DRV:
             while (pItems)
             {
+                if (!pQueue->u.Drv.pfnCallback(pQueue->u.Drv.pDrvIns, pItems))
+                    break;
                 pCur = pItems;
                 pItems = pItems->pNextR3;
-                if (!pQueue->u.Drv.pfnCallback(pQueue->u.Drv.pDrvIns, pCur))
-                    break;
                 pdmR3QueueFree(pQueue, pCur);
             }
             break;
@@ -743,10 +743,10 @@ static bool pdmR3QueueFlush(PPDMQUEUE pQ
         case PDMQUEUETYPE_INTERNAL:
             while (pItems)
             {
+                if (!pQueue->u.Int.pfnCallback(pQueue->pVMR3, pItems))
+                    break;
                 pCur = pItems;
                 pItems = pItems->pNextR3;
-                if (!pQueue->u.Int.pfnCallback(pQueue->pVMR3, pCur))
-                    break;
                 pdmR3QueueFree(pQueue, pCur);
             }
             break;
@@ -754,10 +754,10 @@ static bool pdmR3QueueFlush(PPDMQUEUE pQ
         case PDMQUEUETYPE_EXTERNAL:
             while (pItems)
             {
+                if (!pQueue->u.Ext.pfnCallback(pQueue->u.Ext.pvUser, pItems))
+                    break;
                 pCur = pItems;
                 pItems = pItems->pNextR3;
-                if (!pQueue->u.Ext.pfnCallback(pQueue->u.Ext.pvUser, pCur))
-                    break;
                 pdmR3QueueFree(pQueue, pCur);
             }
             break;
@@ -773,30 +773,34 @@ static bool pdmR3QueueFlush(PPDMQUEUE pQ
     if (pItems)
     {
         /*
-         * Shit, no!
-         *      1. Insert pCur.
-         *      2. Reverse the list.
-         *      3. Insert the LIFO at the tail of the pending list.
+         * Reverse the list.
          */
-        pCur->pNextR3 = pItems;
-        pItems = pCur;
-
-        //pCur = pItems;
+        pCur = pItems;
         pItems = NULL;
         while (pCur)
         {
             PPDMQUEUEITEMCORE pInsert = pCur;
-            pCur = pCur->pNextR3;
+            pCur = pInsert->pNextR3;
             pInsert->pNextR3 = pItems;
             pItems = pInsert;
         }
 
-        if (!ASMAtomicCmpXchgPtr((void * volatile *)&pQueue->pPendingR3, pItems, NULL))
+        /*
+         * Insert the list at the tail of the pending list.
+         */
+        for (;;)
         {
-            pCur = pQueue->pPendingR3;
-            while (pCur->pNextR3)
-                pCur = pCur->pNextR3;
-            pCur->pNextR3 = pItems;
+            if (ASMAtomicCmpXchgPtr((void * volatile *)&pQueue->pPendingR3, pItems, NULL))
+                break;
+            PPDMQUEUEITEMCORE pPending = (PPDMQUEUEITEMCORE)ASMAtomicXchgPtr((void * volatile *)&pQueue->pPendingR3, NULL);
+            if (pPending)
+            {
+                pCur = pPending;
+                while (pCur->pNextR3)
+                    pCur = pCur->pNextR3;
+                pCur->pNextR3 = pItems;
+                pItems = pPending;
+            }
         }
         return false;
     }
diff -up VirtualBox-3.0.0_OSE/src/VBox/VMM/VMMAll/PDMAllQueue.cpp.netfreeze VirtualBox-3.0.0_OSE/src/VBox/VMM/VMMAll/PDMAllQueue.cpp
--- VirtualBox-3.0.0_OSE/src/VBox/VMM/VMMAll/PDMAllQueue.cpp.netfreeze	2009-06-24 15:38:13.114408205 +0200
+++ VirtualBox-3.0.0_OSE/src/VBox/VMM/VMMAll/PDMAllQueue.cpp	2009-07-10 14:57:54.000000000 +0200
@@ -91,6 +91,7 @@ VMMDECL(void) PDMQueueInsert(PPDMQUEUE p
         PVM pVM = pQueue->CTX_SUFF(pVM);
         Log2(("PDMQueueInsert: VM_FF_PDM_QUEUES %d -> 1\n", VM_FF_ISSET(pVM, VM_FF_PDM_QUEUES)));
         VM_FF_SET(pVM, VM_FF_PDM_QUEUES);
+        ASMAtomicBitSet(&pVM->pdm.s.fQueueFlushing, PDM_QUEUE_FLUSH_FLAG_PENDING_BIT);
 #ifdef IN_RING3
         REMR3NotifyQueuePending(pVM); /** @todo r=bird: we can remove REMR3NotifyQueuePending and let VMR3NotifyFF do the work. */
         VMR3NotifyGlobalFFU(pVM->pUVM, VMNOTIFYFF_FLAGS_DONE_REM);
